/*
 * Made with all the love in the world
 * by scireum in Remshalden, Germany
 *
 * Copyright by scireum GmbH
 * http://www.scireum.de - info@scireum.de
 */

package sirius.db.mixing.query;

import sirius.db.mixing.BaseEntity;
import sirius.db.mixing.BaseMapper;
import sirius.db.mixing.EntityDescriptor;
import sirius.db.mixing.Mapping;
import sirius.db.mixing.query.constraints.Constraint;
import sirius.db.mixing.query.constraints.FilterFactory;

import javax.annotation.Nullable;
import java.util.function.Consumer;

/**
 * Describes the minimal functionality to be supported by a query generated by a {@link BaseMapper mapper}.
 *
 * @param <Q> the effective type of the query
 * @param <E> the type of entities being queried
 * @param <C> the type of constraints accepted by this query
 */
public abstract class Query<Q, E extends BaseEntity<?>, C extends Constraint> extends BaseQuery<Q, E> {

    protected Query(EntityDescriptor descriptor) {
        super(descriptor);
    }

    /**
     * Applies the given constraints to the query.
     *
     * @param constraint the constraint which has to be fulfilled
     * @return the query itself for fluent method calls
     */
    public abstract Q where(C constraint);

    /**
     * Provides access to the filter implementation used by the underlying {@link BaseMapper}.
     *
     * @return the filter factory to use for this query
     */
    public abstract FilterFactory<C> filters();

    /**
     * Adds a constraint which ensures that the given field contains the given value.
     *
     * @param field the name of the field to filter on
     * @param value the value to filter on
     * @return the query itself for fluent method calls
     */
    public Q eq(Mapping field, Object value) {
        return where(filters().eq(field, value));
    }

    /**
     * Adds a constraint which ensures that the given field does not contain the given value.
     *
     * @param field the name of the field to filter on
     * @param value the value to filter on
     * @return the query itself for fluent method calls
     */
    public Q ne(Mapping field, Object value) {
        return where(filters().ne(field, value));
    }

    /**
     * Adds a constraint which ensures that the given field contains the given value.
     * <p>
     * If the given value is <tt>null</tt>, the constraint is skipped.
     *
     * @param field the field to check
     * @param value the value to filter on
     * @return the query itself for fluent method calls
     */
    public Q eqIgnoreNull(Mapping field, Object value) {
        return where(filters().eqIgnoreEmpty(field, value));
    }

    /**
     * Adds a query string filter to the given query.
     *
     * @param query  the query to search for
     * @param fields the fields to search in
     * @return the query itself for fluent method calls
     * @see FilterFactory#queryString(EntityDescriptor, String, QueryField...)
     */
    public Q queryString(String query, QueryField... fields) {
        return where(filters().queryString(descriptor, query, fields));
    }

    /**
     * Adds a sort constraint to order by the given field ascending.
     *
     * @param field the field to order by.
     * @return the builder itself for fluent method calls
     */
    public abstract Q orderAsc(Mapping field);

    /**
     * Adds a sort constraint to order by the given field descending.
     *
     * @param field the field to order by.
     * @return the builder itself for fluent method calls
     */
    public abstract Q orderDesc(Mapping field);

    /**
     * Executes the query and counts the number of results.
     * <p>
     * Note that this will ignore any {@link #skip(int) skip} or {@link #limit(int) limit} settings on the query.
     *
     * @return the number of matched result entries
     */
    public abstract long count();

    /**
     * Determines if the query would have at least one matching entity.
     * <p>
     * Note that this will ignore any {@link #skip(int) skip} or {@link #limit(int) limit} settings on the query.
     *
     * @return <tt>true</tt> if at least one entity matches the query, <tt>false</tt> otherwise.
     */
    public abstract boolean exists();

    /**
     * Deletes all matches using the {@link BaseMapper#delete(BaseEntity)} of the appropriate mapper.
     * <p>
     * Be aware that this might be slow for very large result sets.
     *
     * @param entityCallback a callback to be invoked for each entity to be deleted
     */
    public abstract void delete(@Nullable Consumer<E> entityCallback);

    /**
     * Deletes all matches using the {@link BaseMapper#delete(BaseEntity)} of the appropriate mapper.
     * <p>
     * Be aware that this might be slow for very large result sets.
     */
    public void delete() {
        delete(null);
    }

    /**
     * Deletes all matches using the capabilities of the underlying database.
     * <p>
     * Therefore <b>no checks</b> or anything will be invoked for the deleted entities.
     * <p>
     * Use this for larger result sets where integrity and constraints do not matter or are managed manually.
     */
    public abstract void truncate();
}
