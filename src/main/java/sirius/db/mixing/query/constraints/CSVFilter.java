/*
 * Made with all the love in the world
 * by scireum in Remshalden, Germany
 *
 * Copyright by scireum GmbH
 * http://www.scireum.de - info@scireum.de
 */

package sirius.db.mixing.query.constraints;

import sirius.db.mixing.Mapping;
import sirius.kernel.commons.Strings;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.stream.Stream;

/**
 * Represents a constraint which checks if the given field contains one or all of the values given as a comma
 * separated string. By default the given String will be split on "," and "|" but you can also use {@link
 * #customSplitter(String)} to split by a custom Regular Expression.
 * <p>
 * Therefore the constraint translates x,y,z for field f to: {@code f = x OR f = y OR f = z}. Empty strings
 * are gracefully handled (ignored). If {@link #orEmpty()} is used, the constraint also succeeds if
 * the target field is empty. This is only valid when <tt>containsAny</tt> is used.
 *
 * @param <C> the effective type of constraint generated by this builder
 */
public class CSVFilter<C extends Constraint> {

    protected static final String DEFAULT_SPLITTER = "[,|]";

    /**
     * Specifies the matching mode for a filter.
     */
    public enum Mode {
        CONTAINS_ANY, CONTAINS_ALL
    }

    protected FilterFactory<C> factory;
    protected final Mapping field;
    protected boolean orEmpty = false;
    protected Mode mode;
    protected String commaSeparatedValues;
    protected String splitter;
    protected boolean lowercaseValues;
    protected boolean uppercaseValues;

    protected CSVFilter(FilterFactory<C> factory, Mapping field, String value, Mode mode) {
        this.factory = factory;
        this.field = field;
        this.splitter = DEFAULT_SPLITTER;
        this.mode = mode;
        this.commaSeparatedValues = value;
    }

    /**
     * Signals that this constraint should convert the values to lowercase before being applied
     *
     * @return the constraint itself for fluent method calls
     */
    public CSVFilter<C> lowercaseValues() {
        lowercaseValues = true;
        return this;
    }

    /**
     * Signals that this constraint should convert the values to uppercase before being applied
     *
     * @return the constraint itself for fluent method calls
     */
    public CSVFilter<C> uppercaseValues() {
        uppercaseValues = true;
        return this;
    }

    /**
     * Signals that this constraint should split the give values String using the given Regular Expression
     *
     * @param customSplitter a Regular Expression used to split
     * @return the constraint itself for fluent method calls
     */
    public CSVFilter<C> customSplitter(String customSplitter) {
        splitter = customSplitter;
        return this;
    }

    /**
     * Signals the constraint to also accept an empty target field if <tt>containsAny</tt> is used.
     *
     * @return the constraint itself for fluent method calls
     */
    public CSVFilter<C> orEmpty() {
        if (mode == Mode.CONTAINS_ALL) {
            throw new IllegalStateException("Cannot apply a CONTAINS ALL constraint which accepts empty values.");
        }

        this.orEmpty = true;
        return this;
    }

    /**
     * Generates the effective constraint.
     *
     * @return the constraint to be added to a {@link sirius.db.mixing.query.Query}.
     */
    public C build() {
        List<String> values = collectValues();
        if (values.isEmpty()) {
            return null;
        }

        List<C> constraints = new ArrayList<>();
        for (String val : values) {
            constraints.add(factory.eq(field, val));
        }

        C orEmptyConstraint = orEmpty ? factory.isEmptyList(field) : null;

        if (mode == Mode.CONTAINS_ANY) {
            constraints.add(orEmptyConstraint);
            return factory.or(constraints);
        }

        return factory.or(factory.and(constraints), orEmptyConstraint);
    }

    protected List<String> collectValues() {
        if (Strings.isEmpty(commaSeparatedValues)) {
            return Collections.emptyList();
        }

        Stream<String> stream = Arrays.stream(commaSeparatedValues.split(splitter))
                                      .filter(Objects::nonNull)
                                      .map(String::trim)
                                      .filter(Strings::isFilled);
        if (lowercaseValues) {
            stream = stream.map(String::toLowerCase);
        }
        if (uppercaseValues) {
            stream = stream.map(String::toUpperCase);
        }
        return stream.toList();
    }
}
